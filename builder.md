# [Builder](../src/vmm/src/config/builder.rs)

Provides abstraction for building `VMMConfig` and configuring block, memory, network and Virtualised cpus of the the virtal machine.

# Code Explanantion

First the below struct `VMMconfig` defined in [mod.rs]((../src/vmm/src/config/mod.rs)), which holds the configuration for the vrtual machine made. 
```rs
pub struct VMMConfig {
    /// Guest memory configuration.
    pub memory_config: MemoryConfig,
    /// vCPU configuration.
    pub vcpu_config: VcpuConfig,
    /// Guest kernel configuration.
    pub kernel_config: KernelConfig,
    /// Network device configuration.
    pub net_config: Option<NetConfig>,
    /// Block device configuration.
    pub block_config: Option<BlockConfig>,
}
```

```rs
pub struct Builder {
    inner: Result<VMMConfig, ConversionError>,
}
```
Struct Builder (defined above) holds the inner member, which is used to configure VMM object. 

```rs
impl Default for Builder {
    fn default() -> Self {
        Builder {
            inner: Ok(VMMConfig::default()),
        }
    }
}
```
The default fuction of Builder struct is used to initialise the VMMConfig to its default values, generated by trait.

Next, the below fuction is used to check if all the configurations in VMMConfig are setup properly and the kernel path is not empty.
```rs
pub fn build(&self) -> Result<VMMConfig, ConversionError> {
        // Check if there are any errors
    match &self.inner {
        Ok(vc) => {
            // Empty kernel image path.
            if vc.kernel_config.path.to_str().unwrap().is_empty() {
                return Err(ConversionError::ParseKernel(
                    "Kernel Image Path is Empty.".to_string(),
                ));
            }
        }
        Err(_) => {}
    }
    self.inner.clone()
}
```
Here, it is assumed the before calling build all the other config fuction defined below are called.

The below fuction is used later on in the code.
```rs
fn and_then<F>(self, func: F) -> Self
where
    F: FnOnce(VMMConfig) -> Result<VMMConfig, ConversionError>,
{
    Builder {
        inner: self.inner.and_then(func),
    }
}
```
This fuction takes input a closure and applies it on the inner member which is a VMM config object that the struct builder holds. The and_then returns none
if either inner or the func returns none, else it will apply function func on the inner. 

The following fuction is used to configure the memory of the VMM config object that builder is holding.
```rs
pub fn memory_config<T>(self, memory: Option<T>) -> Self
where
    MemoryConfig: TryFrom<T>,
    <MemoryConfig as TryFrom<T>>::Error: Into<ConversionError>,
{
    match memory {
        Some(m) => self.and_then(|mut config| {
            config.memory_config = TryFrom::try_from(m).map_err(Into::into)?;
            Ok(config)
        }),
        None => self,
    }
}
```
It tries to change the memory field present in VMMconfig object of the builder, if operation is not successful it returns error. 

Similarly, the rest of the fuctions in the file try to  change the kernel, vcpu, net and block fields present in the VMMconfig object of the builder.

Below is enum for the error returned by the above functions:

```rs
pub enum ConversionError {
    /// Failed to parse the string representation for the kernel.
    ParseKernel(String),
    /// Failed to parse the string representation for guest memory.
    ParseMemory(String),
    /// Failed to parse the string representation for the vCPUs.
    ParseVcpus(String),
    /// Failed to parse the string representation for the network.
    ParseNet(String),
    /// Failed to parse the string representation for the block.
    ParseBlock(String),
}
```
To use the builder, here is the example snippet
```rs
 use vmm::VMMConfig;
 let vmmconfig = VMMConfig::builder()
      .memory_config(Some("size_mib=1024"))
      .vcpu_config(Some("num=1"))
      .kernel_config(Some("path=/path/to/bzImage"))
      .net_config(Some("tap=tap0"))
      .block_config(Some("path=/dev/loop0"))
      .build();
  assert!(vmmconfig.is_ok());
```

The above code, first makes a builder object, then configures memory, vcpu, kernel, net and block members, and then call build which checks each member
and returns the VMMconfig object.
